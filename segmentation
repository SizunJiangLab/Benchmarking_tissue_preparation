# DUMMY - fill with cleaned skript

# to analyze same ROI in 4 consecutive slides in Visual Studio Code Version 1.89.1 (code by Jason Yeung)
# path to the final fusion qptiff
# the qptiff needs to be accessible to the analysis server (darthvader)


image1 = glob.glob('/mnt/nfs/storage/Fusion_Registered_Report/Slide 1_20 min HIER 1h RT stain_Scan1.qptiff') # glob allows you to pull multiple files using a regular expression, but not necessary here
print(image1)

image2 = glob.glob('/mnt/nfs/storage/Fusion_Registered_Report/Slide 2_20 min HIER on 4C stain_Scan1.qptiff') # glob allows you to pull multiple files using a regular expression, but not necessary here
print(image2)

image3= glob.glob('/mnt/nfs/storage/Fusion_Registered_Report/Slide 3_10 min HIER on 4C stain_Scan1.qptiff') # glob allows you to pull multiple files using a regular expression, but not necessary here
print(image3)

image4= glob.glob('/mnt/nfs/storage/Fusion_Registered_Report/Slide 4_40 min HIER on 4C stain_Scan1.qptiff') # glob allows you to pull multiple files using a regular expression, but not necessary here
print(image4)

# open the image and check dimensions
slide1 = tifffile.imread(image1[0])
slide1.shape

slide2 = tifffile.imread(image2[0])
slide2.shape

slide3 = tifffile.imread(image3[0])
slide3.shape

slide4 = tifffile.imread(image4[0])
slide4.shape

# use this to check which marker is which index in the qptiff
# indexing in python starts at 0 not at 1 like in R, so [0, :, :] = C1 in the qptiff
plt.figure(figsize = (5, 5))
plt.imshow(slide1[0, :, :]);

plt.figure(figsize = (5, 5))
plt.imshow(slide2[0, :, :]);

plt.figure(figsize = (5, 5))
plt.imshow(slide3[0, :, :]);

plt.figure(figsize = (5, 5))
plt.imshow(slide4[0, :, :]);

# 0 = DAPI
# 1 = CD3
# 2 = aSMA
# 3 = CD15
# 4 = CD4
# 5 = CD8
# 6 = CD11b
# 7 = CD11c
# 8 = CD20
# 9 = CCD21
# 10 = CH2K27me3
# 11 = Ki-67
# 12 = HLA-DRA
# 13 = Histone H3
# 14 = CD68
# 15 = DC-SIGN
# 16 = Foxp3
# 17 = PD-1
# 18 = CD163
# 19 = H3K27ac
# 20 = Granzyme B
# 21 = CD31
# 22 = CD206
# 23 = 138
# 24 = NaK ATPase
# 25 = CD45RA
# 26 = CD45
# 27 = Cytokeratin

nuclear1 = np.zeros((21600, 26880))
membrane1 = np.zeros((21600, 26880))

nuclear_markers = [0] # these are indices of the channels we want to use as the nuclear signal (only one here)
membrane_markers = [1, 4, 5, 6, 8, 14, 21, 22, 23, 24, 25, 27] # these are the indices we want to use as the membrane signal (referenced above)

for chn_index in range(len(slide1)):
    arr = slide1[chn_index, :, :] # slice the corresponding index in the first dimension
    if chn_index in nuclear_markers: # if the chn_index is in our list of nuclear markers, stack it to the nuclear array
        nuclear1 = np.add(nuclear1, arr)
    elif chn_index in membrane_markers: # if the chn_index is a membrane_marker, stack it to the membrane array
        membrane1 = np.add(membrane1, arr)
    else:
        pass
    

nuclear2 = np.zeros((16560, 24960))
membrane2 = np.zeros((16560, 24960))

nuclear_markers = [0] # these are indices of the channels we want to use as the nuclear signal (only one here)
membrane_markers = [1, 4, 5, 6, 8, 14, 21, 22, 23, 24, 25, 27] # these are the indices we want to use as the membrane signal (referenced above)

for chn_index in range(len(slide2)):
    arr = slide2[chn_index, :, :] # slice the corresponding index in the first dimension
    if chn_index in nuclear_markers: # if the chn_index is in our list of nuclear markers, stack it to the nuclear array
        nuclear2 = np.add(nuclear2, arr)
    elif chn_index in membrane_markers: # if the chn_index is a membrane_marker, stack it to the membrane array
        membrane2 = np.add(membrane2, arr)
    else:
        pass


    nuclear3 = np.zeros((25200, 33600))
membrane3 = np.zeros((25200, 33600))

nuclear_markers = [0] # these are indices of the channels we want to use as the nuclear signal (only one here)
membrane_markers = [1, 4, 5, 6, 8, 14, 21, 22, 23, 24, 25, 27] # these are the indices we want to use as the membrane signal (referenced above)

for chn_index in range(len(slide3)):
    arr = slide3[chn_index, :, :] # slice the corresponding index in the first dimension
    if chn_index in nuclear_markers: # if the chn_index is in our list of nuclear markers, stack it to the nuclear array
        nuclear3 = np.add(nuclear3, arr)
    elif chn_index in membrane_markers: # if the chn_index is a membrane_marker, stack it to the membrane array
        membrane3 = np.add(membrane3, arr)
    else:
        pass

nuclear4 = np.zeros((22320, 25920))
membrane4 = np.zeros((22320, 25920))

nuclear_markers = [0] # these are indices of the channels we want to use as the nuclear signal (only one here)
membrane_markers = [1, 4, 5, 6, 8, 14, 21, 22, 23, 24, 25, 27] # these are the indices we want to use as the membrane signal (referenced above)

for chn_index in range(len(slide4)):
    arr = slide4[chn_index, :, :] # slice the corresponding index in the first dimension
    if chn_index in nuclear_markers: # if the chn_index is in our list of nuclear markers, stack it to the nuclear array
        nuclear4 = np.add(nuclear4, arr)
    elif chn_index in membrane_markers: # if the chn_index is a membrane_marker, stack it to the membrane array
        membrane4 = np.add(membrane4, arr)
    else:
        pass

 # show the final nuclear and membrane arrays as images
fig, ax = plt.subplots(1, 2, figsize=(10, 10))
ax[0].imshow(nuclear1)
ax[1].imshow(membrane1)

ax[0].set_title('nuclear1')
ax[1].set_title('membrane1');


fig, ax = plt.subplots(1, 2, figsize=(10, 10))
ax[0].imshow(nuclear2)
ax[1].imshow(membrane2)

ax[0].set_title('nuclear2')
ax[1].set_title('membrane2');


fig, ax = plt.subplots(1, 2, figsize=(10, 10))
ax[0].imshow(nuclear3)
ax[1].imshow(membrane3)

ax[0].set_title('nuclear3')
ax[1].set_title('membrane3');


fig, ax = plt.subplots(1, 2, figsize=(10, 10))
ax[0].imshow(nuclear4)
ax[1].imshow(membrane4)

ax[0].set_title('nuclear4')
ax[1].set_title('membrane4');

# save nuclear and membrane tiffs for future reference 
# (can also check that nuclear is actually nuclear by opening the image, hard to tell in a python notebook)
imsave("MESMER_outputs/nuclear1.tiff", nuclear1, check_contrast = False)
imsave("MESMER_outputs/membrane1.tiff", membrane1, check_contrast = False)

imsave("MESMER_outputs/nuclear2.tiff", nuclear2, check_contrast = False)
imsave("MESMER_outputs/membrane2.tiff", membrane2, check_contrast = False)

imsave("MESMER_outputs/nuclear3.tiff", nuclear3, check_contrast = False)
imsave("MESMER_outputs/membrane3.tiff", membrane3, check_contrast = False)

imsave("MESMER_outputs/nuclear4.tiff", nuclear4, check_contrast = False)
imsave("MESMER_outputs/membrane4.tiff", membrane4, check_contrast = False)

# stack the nuclear and membrane arrays we created
stack1 = np.stack((nuclear1, membrane1), axis = -1)

# also expand to 4 dimensions
stack1 = np.expand_dims(stack1, 0)
stack1.shape

# stack the nuclear and membrane arrays we created
stack2 = np.stack((nuclear2, membrane2), axis = -1)

# also expand to 4 dimensions
stack2 = np.expand_dims(stack2, 0)
stack2.shape

# stack the nuclear and membrane arrays we created
stack3 = np.stack((nuclear3, membrane3), axis = -1)

# also expand to 4 dimensions
stack3 = np.expand_dims(stack3, 0)
stack3.shape

# stack the nuclear and membrane arrays we created
stack4 = np.stack((nuclear4, membrane4), axis = -1)

# also expand to 4 dimensions
stack4 = np.expand_dims(stack4, 0)
stack4.shape

y_min1 = 9500
y_max1 = 15000
x_min1 = 5000
x_max1 = 12000

fig, ax = plt.subplots(1, 2, figsize=(10, 10))
ax[0].imshow(stack1[0, :, :, 0])
ax[1].imshow(stack1[0, y_min1:y_max1, x_min1:x_max1, 0])

ax[0].set_title('full1')
ax[1].set_title('cropped1');

y_min2 = 4000
y_max2 = 9500
x_min2 = 3000
x_max2 = 10000

fig, ax = plt.subplots(1, 2, figsize=(10, 10))
ax[0].imshow(stack2[0, :, :, 0])
ax[1].imshow(stack2[0, y_min2:y_max2, x_min2:x_max2, 0])

ax[0].set_title('full2')
ax[1].set_title('cropped2');

y_min3 = 5500
y_max3 = 11000
x_min3 = 8600
x_max3 = 15600

fig, ax = plt.subplots(1, 2, figsize=(10, 10))
ax[0].imshow(stack3[0, :, :, 0])
ax[1].imshow(stack3[0, y_min3:y_max3, x_min3:x_max3, 0])

ax[0].set_title('full3')
ax[1].set_title('cropped3');

y_min4 = 9600
y_max4 = 15100
x_min4 = 3200
x_max4 = 10200

fig, ax = plt.subplots(1, 2, figsize=(10, 10))
ax[0].imshow(stack4[0, :, :, 0])
ax[1].imshow(stack4[0, y_min4:y_max4, x_min4:x_max4, 0])

ax[0].set_title('full4')
ax[1].set_title('cropped4');

cropped_stack1 = stack1[:, y_min1:y_max1, x_min1:x_max1, :]
cropped_stack1.shape
cropped_stack2 = stack2[:, y_min2:y_max2, x_min2:x_max2, :]
cropped_stack2.shape
cropped_stack3 = stack3[:, y_min3:y_max3, x_min3:x_max3, :]
cropped_stack3.shape
cropped_stack4 = stack4[:, y_min4:y_max4, x_min4:x_max4, :]
cropped_stack4.shape

# these are the Mesmer default parameters for reference:
# default_kwargs_cell = {
#             'maxima_threshold': 0.075,
#             'maxima_smooth': 0,
#             'interior_threshold': 0.2,
#             'interior_smooth': 2,
#             'small_objects_threshold': 15,
#             'fill_holes_threshold': 15,
#             'radius': 2
#         }

# MESMER PARAMETERS
# mpp = microns per pixel resolution, should be static based on experiment
# I believe the phenoimager resolution is advertised as 0.5 mpp at 20x but you guys probably know better than me
image_mpp = 0.50

# maxima_threshold controls what is considered a unique cell (lower values = more separate cells, higher values = fewer cells)
# interior_threshold determines what is considered background/not part of a cell (lower value = larger cells)
maxima_threshold = 0.075
interior_threshold = 0.2

%%time

# run segmentation
app = Mesmer()
predictions1 = app.predict(cropped_stack1, image_mpp = image_mpp,
                          postprocess_kwargs_whole_cell = {"maxima_threshold": maxima_threshold,
                                                           "interior_threshold": interior_threshold})
%%time

app = Mesmer()
predictions2 = app.predict(cropped_stack2, image_mpp = image_mpp,
                          postprocess_kwargs_whole_cell = {"maxima_threshold": maxima_threshold,
                                                           "interior_threshold": interior_threshold})

%%time

app = Mesmer()
predictions3 = app.predict(cropped_stack3, image_mpp = image_mpp,
                          postprocess_kwargs_whole_cell = {"maxima_threshold": maxima_threshold,
                                                           "interior_threshold": interior_threshold})

%%time
app = Mesmer()
predictions4 = app.predict(cropped_stack4, image_mpp = image_mpp,
                          postprocess_kwargs_whole_cell = {"maxima_threshold": maxima_threshold,
                                                           "interior_threshold": interior_threshold})


rgb_image = create_rgb_image(cropped_stack1, channel_colors = ["green", "blue"])
overlay = make_outline_overlay(rgb_data = rgb_image, predictions = predictions1)

# save MESMER outputs
output_dir = f'/mnt/nfs/home/johannaschaffenrath/RReportexp/MESMER_outputs/{maxima_threshold}maxima_1_{interior_threshold}interior_1/'
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

skimage.io.imsave(output_dir + "seg_outline1.tiff", img_as_ubyte(overlay[0, ..., 0]), check_contrast = False) # segmentation outline
skimage.io.imsave(output_dir + "seg_overlay1.tiff", img_as_ubyte(overlay[0, ...]), check_contrast = False) # segmentation overlay (nuc + membrane + outline)
skimage.io.imsave(output_dir + "MESMER_mask1.tiff", predictions1[0, ..., 0], check_contrast = False) # MESMER mask

rgb_image = create_rgb_image(cropped_stack2, channel_colors = ["green", "blue"])
overlay = make_outline_overlay(rgb_data = rgb_image, predictions = predictions2)

output_dir = f'/mnt/nfs/home/johannaschaffenrath/RReportexp/MESMER_outputs/{maxima_threshold}maxima_2_{interior_threshold}interior_2/'
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

skimage.io.imsave(output_dir + "seg_outline2.tiff", img_as_ubyte(overlay[0, ..., 0]), check_contrast = False) # segmentation outline
skimage.io.imsave(output_dir + "seg_overlay2.tiff", img_as_ubyte(overlay[0, ...]), check_contrast = False) # segmentation overlay (nuc + membrane + outline)
skimage.io.imsave(output_dir + "MESMER_mask2.tiff", predictions2[0, ..., 0], check_contrast = False) # MESMER mask

rgb_image = create_rgb_image(cropped_stack3, channel_colors = ["green", "blue"])
overlay = make_outline_overlay(rgb_data = rgb_image, predictions = predictions3)


output_dir = f'/mnt/nfs/home/johannaschaffenrath/RReportexp/MESMER_outputs/{maxima_threshold}maxima_3_{interior_threshold}interior_3/'
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

skimage.io.imsave(output_dir + "seg_outline3.tiff", img_as_ubyte(overlay[0, ..., 0]), check_contrast = False) # segmentation outline
skimage.io.imsave(output_dir + "seg_overlay3.tiff", img_as_ubyte(overlay[0, ...]), check_contrast = False) # segmentation overlay (nuc + membrane + outline)
skimage.io.imsave(output_dir + "MESMER_mask3.tiff", predictions3[0, ..., 0], check_contrast = False) # MESMER mask

rgb_image = create_rgb_image(cropped_stack4, channel_colors = ["green", "blue"])
overlay = make_outline_overlay(rgb_data = rgb_image, predictions = predictions4)


output_dir = f'/mnt/nfs/home/johannaschaffenrath/RReportexp/MESMER_outputs/{maxima_threshold}maxima_4_{interior_threshold}interior_4/'
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

skimage.io.imsave(output_dir + "seg_outline4.tiff", img_as_ubyte(overlay[0, ..., 0]), check_contrast = False) # segmentation outline
skimage.io.imsave(output_dir + "seg_overlay4.tiff", img_as_ubyte(overlay[0, ...]), check_contrast = False) # segmentation overlay (nuc + membrane + outline)
skimage.io.imsave(output_dir + "MESMER_mask4.tiff", predictions4[0, ..., 0], check_contrast = False) # MESMER mask


